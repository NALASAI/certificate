애플리케이션 테스트
- 애플리케이션 테스트의 개념
* 잠재되어있는 결함을 찾아내는 행위, 고객 요구 확인, 소프트웨어 기능 수행여부 검증
- 애플리케이션 테스트의 필요성
* 프로그램이 실행되기 전 오류 발견 예방, 반복적 Test -> 신뢰도 향상, 오류발견 및 오류유입 예방
- 애플리케이션 테스트의 기본 원리
* 잠재적 결함 저하, 증명 불가, 완벽 불가, 결함 - 특정한 모듈에 집중
* 오류 부지 법칙 : 결함 제거 -> 사용자 요구 만족 X -> 품질이 낮다
* 파레토 법칙 : 20%코드에서 전체 80%의 결함이 발견된다
* 테스트와 위험은 반비례 관계, 테스트는 작은 부분부터 점차적으로 진행해야한다.

애플리케이션 테스트의 분류
- 프로그램 실행 여부에 따른 테스트
* 정적 테스트 : 프로그램 미실행, 소스코드 대상 테스트, 개발 초기에 오류 발견, 소프트웨어 비용 절감	ex)워크스루, 인스펙션, 코드검사
* 동적 테스트 : 프로그램 실행, 소프트웨어 개발 모든단계 테스트 수행 가능		ex)블랙박스 테스트, 화이트박스 테스트
- 테스트 기반(Test Bases)에 따른 테스트
* 명세 기반 테스트 : 사용자의 요구사항 명세화 후 전부 테스트 케이스로 구현하고 확인하는 테스트	
ex) 동등분할, 경계값 분석
* 구조 기반 테스트 : 내부 논리적 흐름에 따른 테스트 케이스로 작성후 확인하는 테스트
* 경험 기반 테스트 : 테스터에 대한 경험을 기반으로 한 테스트, [요구사항 명세 불분명, 테스트 시간 제약] 와 같은 상황에서 더욱 효과적이다.
- 시각에 따른 테스트
* 검증 테스트 : 개발자 시각, 명세서 기반 제품
* 확인 테스트 : 사용자 시각, 사용자 요구 제품
- 목적에 따른 테스트
* 회복 테스트(결함-실패-복구), 안전 테스트(보호), 강도 테스트(과도한 분량 - 과부화)
* 성능 테스트, 구조 테스트(논리적 경로, 소스코드의 복잡도), 회귀 테스트([변경, 수정]코드에서 새로운 결함 여부 확인)
* 병행 테스트(변경 SW, 기존 SW)

테스트 기법에 따른 애플리케이션 테스트
- 화이트박스 테스트(White Box Test)
* 화이트 박스 : 논리위주의 테스트방식, 내부소스코드 테스트 방식, 내부의 논리적인 구조, 복잡도
# 원시코드, 많은 시간 분석 -> 오류위치
* 기초 경로 검사 - 논리적 복잡성
ex) 원시 코드 - 흐름도 작성 - 논리적 복잡도측정 
* 제어 구조 검사
1) 조건 검사
2) 루프 검사
3) 데이터흐름 검사
- 블랙박스 테스트(Black Box Test)
: 소프트웨어 동작 - 내부 x, 입력값과 출력값 대상 - 기능 유효성 테스트
: 기능 작동 여부, 입력 및 출력 확인, 역활 확인, 정상 작동 여부(기능 검사)
* 동치분할 검사 : 입력 자료 초점
* 경계값 분석 : 입력 조건의 경계값 초점
* 원인/효과 그래프 검사 : [입력 데이터 간의 관계, 출력값에 대한 영향] 에 대한 검사
* 오류 예측 검사 : 과거의 경험 대상
* 비교 검사 : 여러 버전의 프로그램을 대상으로 동일한 값이 나오는지 확인

개발 단계에 따른 애플리케이션 테스트
- 단위 테스트(Unit Test) : 모듈 단위로 Test, 화이트박스 테스트 사용
- 통합 테스트(Integation Test) : 모듈이 통합되었을때 작동여부 테스트, 여러 모듈
* 비점진적 통합방식 : 모든 모듈 - 미리 결합 -> 프로그램 전체 검사 ( 오류 발견 어려움, 수정 어려움 )
# 빅뱅 통합검사 : 사전에 미리 결합 - 전체 프로그램은 하나로 Test - 작업이 복잡하다. 수정이 어렵다
* 점진적 통합방식 : 모듈들을 단계적으로 통합
# 하향식 통합 검사 : 상위~하위 통합방식
# 상향식 통합 검사 : 하위~상위 통합방식
# 혼합식 통합 검사 : [하양식, 상향식] 혼합하여 사용하는 방식, 샌드위치 통합 방식
- 검증 테스트 : 사용자 요구사항 충족 검사
* 형상 검사 : 모든 사항 - 동작 검사
* 알파 검사 : 개발자 앞 테스트, 회사 내부에서 실행
* 베타 검사 : 가발자 없이 테스트, 고객 대상 
- 시스템 테스트
* 복구 검사 : 결함 - 실패 - 복구 검사
* 보안 검사 : 부적당한 침투 대응 검사
* 강도 검사 : 비정상적 양 입력 후 동작 성공 여부 검사
* 성능 검사 : 검사단계의 전과정 검사, 실시간 성능 검사

애플리케이션 테스트 프로세스
- 애플리케이션 테스트 프로세스
* 테스트 계획 -> 테스트 분석 및 디자인 -> 테스트 케이스 및 시나리오 작성 -> 테스트 수행-테스트 결과 평가 및 리포팅 -> 결함추적 및 관리
* 테스트 계획서(목적, 범위, 일정, 절차, 대상, 책임), 테스트 케이스(입력값, 실행조건, 기대결과), 테스트 시나리오(수행, 동작순서), 테스트 결과서
- 테스트 계획(대상, 범위)
* 테스트 시작 조건 : 계획, 일정, 환경, 요구사항 명세서, 참여 인력 역할, 책임
* 테스트 종료 조건 : 테스트 완료, 일정 만료, 비용 소진
- 테스트 분석 및 디자인 : 테스트 목적, 원칙 검토, 사용자의 요구사항 분석
- 테스트 케이스 및 시나리오 작성 : 테스트 케이스 작성 - 검토확인 - 시나리오
- 테스트 수행 : 테스트 환경 구축(실제 시스템과 유사한 HW, SW, 네트워크 시설 구축) - 테스트 수행
- 테스트 결과 평가 및 리포팅 : 비교 분석 - 보고서 작성, 결함 기록
- 결함 추적 및 관리
* 에러 발견, 에러 등록, 에러 분석, 결함 확정, 결함 할당, 결함 조치, 결함 조치 검토 및 승인

테스트 케이스/테스트 시나리오/테스트 오라클
- 테스트 케이스(Test Case)
* SW->사용자 요구사항 준수
* -> 설계된 입력값, 실행 조건, 기대결과, 명세서
* 테스트 오류 감소, 인력 및 시간 감소, 시스템 설계시 작성
- 테스트 케이스 작성순서
1) 테스트 계획 검토 및 우선순위 결정 : 재검토, 범위, 접근방법
2) 위험 평가 및 우선 순위 결정 : 위험정도, 초점
3) 테스트 요구사항 정의 : [요구사항, 테스트 대상] -> 재검토
4) 테스트 구조 설계 및 테스트 방법 결정 : 테스트케이스 형식, 분류방법
5) 테스트 케이스 정의 : 요구사항, 작성
6) 테스트 케이스 타당성 확인 및 유지보수 : 갱신
- 테스트 시나리오(Test Scenario) : 테스트케이스 순서에 따라 구체적 절차 문서화
- 테스트 시나리오 작성 시 유의 사항 : [시스템, 모듈, 항목] -> 여러개의 시나리오로 분리하여 사용해야한다, 사용자 요구사항을 토대로 작성, 업무흐름으로 작성 
- 테스트 오라클(Test Oracle) : 사전에 (정의된)참값을 대입, 비교 하는 기법, 예상 결과, 계산 확인
* 특징 : 제한된 검증, 수학적 기법, 자동화 기능
- 테스트 오라클의 종류
* 참 오라클(기대하는 결과, 모든 오류 검출), 샘플링 오라클, 추정 오라클, 일관성 검사 오라클

테스트 자동화 도구
- 테스트 자동화의 개념 : 쉽고 효율적으로 테스트 수행 가능, 휴먼 에러(사람의 실수) 감소, 테스트 정확성 유지, 테스트 품질 향상
- 테스트 자동화 도구의 장점/단점
* 장점 : 데이터 재입력/재구성 등의 반복작업 자동화 -> 테스트 시간 단축, 객관적인 평가, 테스트 결과를 그래프 및 표시형식으로 제공
* 단점 : 사용법에 대한 교육/학습 필요, 비용 발생
- 테스트 자동화 수행 시 고려사항
* 모든 테스트 과정 자동화 도구 X
* 용도에 맞는 적절한 도구 선택
* 환경설정, 습득 기간 -> 일정 계획
* 테스트 엔지니어를 프로젝트 초기에 투입 시기 결정해야한다.
- 테스트 자동화 도구의 유형
* 정적 분석 도구(프로그램 실행 없이 분석하는 도구), 테스트 실행 도구, 성능 테스트 도구(가상의 사용자를 만들어 테스트 수행하는 도구)
* 테스트 통제 도구, 테스트 하네스 도구(모듈 테스트 환경 일부분, 코드/데이터 의미)
- 테스트 수행 단계별 테스트 자동화 도구
	단계 - 자동화 도구
* 테스트 계획 - 요구사항 관리 : 사용자 요구사항 정의, 변경사항 관리
* 테스트 분석/설계 - 테스트 케이스 생성 : 테스트 데이터, 테스트 케이스 작성
* 테스트 수행 - 테스트 자동화, 정적 분석, 동적 분석(시뮬레이션을 통해 오류 검출), 성능 테스트(처리능력 테스트), 모니터링(자원상태 분석)
* 테스트 관리 - 커버리지 분석(충분여부), 형상 관리, 결함 추적/관리

결함 관리
- 결함(Fault)의 정의 : 오류, 작동실패, 설계와는 다른 동작(예상한 결과 ≠ 실제 실행결과)
- 결함 관리 프로세스
* 결함 관리 계획 -> 결함 기록(테스트 중 결함 발견 -> 결함 관리 DB) -> 결함 검토 -> 결함 수정 -> 결함 재확인(결함 수정 -> 확인 후 테스트) ->
* 결함 상태 추적 및 모니터링 활동 -> 최종 결함 분석 및 보고서 작성
- 결함 상태 추적 : 변화/추적/관리
* 결함 분포(결함 수 측정), 결함 추세(테스트 진행 시간에 따른 결함 수 측정), 결함 에이징(특정 결함 상태로 지속 시간 측정)
- 결함 추적 순서 : 
* 결함 등록 -> 결함 검토 -> 결함 할당(담당자) -> 결함 수정 -> 결함 조치 보류(수정불가능 -> 연기) -> 결함 종료(담당자의 종료 승인) -> 결함 해제
- 결함 분류
* 시스템 결함, 기능 결함(사용자의 요구사항 미반영), GUI 결함(화면 설계 결함), 문서 결함(사용자 요구사항 ≠ 기능 교수사항)
- 결함 심각도
* High(프로세스 진행 불가), Medium(시스템 흐름 영향, 부정확한 기능), Low(시스템 흐름에 영향 없음 )
- 결함 우선순위
* 결함 중요도 - 결함 심각도
- 결함 관리 도구
* Mantis(단위별 작업 기록, 결함 추적 가능), Trac(결함 추적, 결함 통합 관리), Redmine(결함 추적), Bugzilla(결함 신고/확인/처리 관리 도구)

애플리케이션 성능 분석
- 애플리케이션 성능 : 최소한의 자원으로 최대한 많은 기능을 신속하게 처리하는 정보
* 처리량 : 일정한 시간 안에 처리하는 일의 양
* 응답시간 : [요청 전달 ~ 응답 도착] 시간
* 경과시간 : [작업 의뢰시간 ~ 처리완료] 시간
* 자원 사용률 : [CPU, 메모리, 네트워크]자원량의 사용률
- 성능 테스트 도구  
* Jmeter : 다양한 프로토콜 지원
* LoadUI : 사용자의 편리성 강화
* OpenSTA : 부하테스트, 생산품 모니터링
- 시스템 모니터링(Monitoring)도구 : 시스템 자원 사용량 확인/분석 도구
* Scouter : 애플리케이션 성능 모니터링/통제 도구
* Zabbix : 웹 기반 모니터링 도구
- 애플리케이션 성능 저하 원인 분석
* 요인 => DB : 많은 데이터 요구
	 커넥션 풀 : DB와 연결된 커넥션(Pool) 미리 제작 후 사용 후 반납하는 기법 
ex) 인터넷 접속 불량, 대량의 파일 업로드 or 다운로드 처리시간 증가, 전송실패, 전송 지연
- 소스코드 최적화
* 클린코드 : 이해하기 쉽다. 수정/추가, 단순하고 명료하다
* 나쁜코드 : 로직이 복잡하다, 이해하기 어려운 코드 많음
* 클린코드 작성 원칙 : 가독성(쉽게 읽을수 있다), 단순성(간단하게 작성), 의존성 배제(다른 모듈 영향 배제), 중복성 최소화(중복된 내용 최소화), 추상화(간략하게 표현)
- 소스코드 최적화 유형
* 클래스 분할 배치(하나의 클래스 : 하나의 역할), 느슨한 결합(의존성 최소화), 코딩 형식 준수(줄바꿈을 통해 가독성 증가, [호출 함수 | 선배치, 호출 되는 함수 | 후배치]
- 소스 코드 품질 분석 도구 : 결함 발견 도구
* 정적 분석도구 : 소스코드 미실행, 코딩 표준, 스타일, 결함 확인	ex)분석 가능 : 코딩 복잡도, 모델 의존성, 불일치성
* 동적 분석도구 : 소스코드 실행
- 소스 코드 품질 분석 도구
* 정적분석 도구 : Pmd(미사용변수, 코드 검사), cppcheck(메모리, 오버플로우), sonarQube(코드 복잡도, 코딩 설계), checkstyle(소스코드 표준), ccm(복잡도), cobertura(JAVA 언어 소스코드 복잡도)
* 동적분석 도구 : avalanche(프로그램 결함, 취약점 분석), valgrind(메모리, 쓰레드)







