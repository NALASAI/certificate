사전 조사 분석
- 물리 데이터베이스 설계(양식설계, 분석 및 설계, 접근 경로 설계)
* 논리적 데이터베이스를 디스크 등 물리적 저장장치(고려사항 : 인덱스 구간, 레코드크기, 레코드 개수, 개념스키마, 수행속도 향상 조건)에 저장할 수 있는 물리적 구조의 데이터로 변환하는 과정
- 데이터 명명 규칙 파악
* 물리 데이터 모델에 적용해야 하는 규칙으로 물리데이터 모델의 설계 전에 파악
* 데이터 표준화 및 논리 데이터베이스 설계의 결과물 등을 통해 파악
* 데이터 명명 규칙을 통해 중복 구축 등을 방지
* 명명 규칙을 파악하려면 도메인과 데이터 사전에 대한 지식이 필요

- 시스템 자원 파악
* 데이터베이스 설치에 영향을 미칠 수 있는 물리적인 요소들로, 사전에 미리 파악해야 한다.
* 시스템 자원 : 하드웨어 자원(CPU, 메모리, 디스크, 네트워크), 운영체제 및 DBMS 버전, DBMS 파라미터(Parameter)정보
- 데이터베이스 관리 요소 파악
* 데이터베이스 운영과 관리 요소로, 데이터베이스 시스템의 환경에 따라 달라질 수 있으므로 미리 파악해야 한다.
* 데이터베이스 시스템 조사 분석서 작성
* 데이터베이스 구조, 이중화 구성, 분산 데이터베이스, 접근 제어/접근 통제, DB암호화 등의 범위와 특성 파악

데이터베이스 저장 공간 설계
- 테이블(Table)
* 데이터베이스의 가장 기본적인 객체로 행과 열로 구성되어 있다.
* 데이터베이스의 모든 데이터는 테이블에 저장된다.
- 일반 테이블
* 현재 사용되는 대부분의 DBMS에서 표준 테이블로 사용되는 테이블 형태
- 클러스터드 인덱스 테이블
* 기본키나 인덱스키의 순서에 따라 데이터가 저장되는 테이블
- 파티셔닝 테이블
* 대용량의 테이블을 작은 논리적 단위인 파티션으로 나눈 테이블
- 외부 테이블
* 데이터베이스에서 일반 테이블처럼 이용할 수 있는 외부 파일로, 데이터베이스 내에 객체로 존재
- 임시 테이블
* 트랜잭션이나 세션별로 데이터를 저장하고 처리할 수 있는 테이블
- 컬럼
* 테이블의 열을 구성하는 요소로 데이터 타입, 길이 등으로 정의된다.
* 참조 관계인 컬럼들은 데이터 타입과 길이가 일치해야 한다.
- 테이블스페이스
* 테이블이 저장되는 논리적인 영역으로, 하나의 테이블스페이스에 하나 또는 그 이상의 테이블을 저장할 수 있다.

트랜잭션 분석 / CRUD 분석
- 트랜잭션의 정의
* 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미힌다.
- 트랜잭션의 특징	(ACID | 원관독영)
* Atomicity(원자성) : 모두 반영되도록 완료 또는 전혀 반영되지 않도록 복구
* Consistency(일관성) : 트랜잭션의 수행 전과 수행 완료 후의 상태가 같아야 한다.
* Isolation(독립성, 격리성, 순차성) : 하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 없다.
* Durability(영속성, 지속성) : 성공적으로 완료된 트랜잭션의 결과는 영구적으로 반영되어야 한다.

- CRUD 분석
* CRUD는 생성(Create), 읽기(Read), 갱신(Update), 삭제(Delete)의 앞 글자만 모아서 만든 용어
* CRUD 분석은 데이터베이스 테이블에 변화를 주는 트랜잭션의 CRUD 연산에 대해 CRUD 매트릭스를 작성하여 분석하는 것
- CRUD 매트릭스
* 2차원 형태의 표로서, 행에는 프로세스를, 열에는 테이블을, 행과 열이 만나는 위치에는 프로세스가 테이블에 발생시키는 변화를 표시하는 업무 프로세스와 데이터 간 상관 분석표이다.
* 우선순위 : C > D > U > R

- 트랜잭션 분석
* 테이블에 발생하는 트랜잭션 양을 분석하여 테이블에 저장되는 데이터의 양을 유추하여 DB 용량을 산정하고 DB 구조를 최적화하는 것
- 트랜잭션 분석서
* 단위 프로세서와 CRUD 매트릭스를 이용하여 작성
* 구성요소 : 단위 프로세스(업무를 발생시키는 가장 작은 단위), CRUD 연산, 테이블 명, 컬럼 명, 테이블 참조 횟수, 트랜잭션 수, 발생 주기

인덱스 설계
- 인덱스(Index)의 개념
* 데이터 레코드를 빠르게 접근하기 위해 <키 값, 포인터> 쌍으로 구성되는 데이터 구조
* 데이터가 저장된 물리적 구조와 밀접한 관계가 있다.
* 인덱스를 통해서 파일의 레코드에 대한 액세스를 빠르게 수행할 수 있다.
* 레코드의 삽입과 삭제가 수시로 일어나는 경우에는 인덱스의 개수를 최소로 하는것이 효율적이다.
* 레코드의 물리적 순서가 인덱스의 엔트리 순서와 일치하게 유지되도록 구성되는 인덱스를 클러스터드(Clustered) 인덱스라 한다
- 트리 기반 인덱스
* 인덱스를 저장하는 블록들이 트리 구조를 이루고 있는 것
* B 트리 인덱스 : 일반적으로 사용되는 인덱스 방식
* B+ 트리 인덱스 : B 트리의 변형, 인덱스 세트(Index Set)(단말노드가 아닌것으로만 구성), 순차 세트(단말노드로만 구성)
- 비트맵 인덱스
* 인덱스 컬럼의 데이터를 Bit 값인 0 또는 1로 변환하여 인덱스 키로 사용하는 방법
- 함수 기반 인덱스
* 컬럼의 값 대신 컬럼에 특정 함수나 수식을 적용하여 산출된 값을 사용하는 것
- 비트맵 조인 인덱스
* 다수의 조인된 객체로 구성된 인덱스
- 도메인 인덱스
* 개발자가 필요한 인덱스르 직접 만들어 사용하는 것
- 인덱스 설계
* 분명하게 드러난 컬럼에 대해 기본적인 인덱스를 먼저 저장한 후 개발(인덱스 대상 테이블 or 컬럼 선정 후 최적화) 단계에서 필요한 인덱스의 설계를 반복적으로 수행
- 인덱스 대상 테이블 선정 기준
* Multi Block Read 수에 따라 판단, 랜덤 액세스가 빈번한 테이블, [특정한 순서로 조회가 필요한 테이블, 순차적인 조인이 발생하는 테이블]
- 인덱스 대상 컬럼 선정 기준
* 인덱스 컬럼의 분포도가 10%~15% 이내인 컬럼[10%~15% 이상 : 부분적 처리 목적 컬럼, 조회, 출력조건]
- 인덱스 설계 시 고려사항
* 새로 추가되는 인덱스는 기존 인덱스 경로에 영향을 미칠 수 있다.
* 인덱스가 많이 발생할 경우 혹은 넓은 범위를 인덱스로 잡을경우에도 오버헤드 발생, 
* 인덱스 공간과 데이터, 테이블 공간은 서로 분리되어야 한다.

뷰(View)의 설계
- 뷰(View)의 개요
* 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된 가상 테이블이다
* 물리적으로 존재하지 않는다. 사용자에게는 있는 것처럼 보여진다, 임시적인 작업용도로 사용된다.
- 뷰(View)의 특징 : 원본에서 유도된 테이블, 기존 테이블과 구조와 조작방법이 같다.
* 물리적으로 구현되어 있지 않다. 데이터의 논리적 독립성을 제공할 수 있다.
* 관리가 용이하다. 명령문이 간단하다.
- 뷰(View)의 장점 : 논리적 데이터 독립성 제공
* 사용자의 데이터 관리를 간단하게 해준다. 접근 제어를 통한 자동 보안이 제공된다.
- 뷰(View)의 단점 : 변경할 수 없다.
* 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신 연산에 제약이 따른다.
- 뷰(View) 설계 순서
* 대상 테이블을 선정한다 - 대상 컬럼을 선정한다(보안을 생각) - 정의서를 작성한다.
* 정의서 ex) 뷰명 뷰설명 테이블 컬럼 데이터타입
- 뷰 설계 시 고려사항
* 반복적으로 조인을 설정하여 사용하거나 동일한 조건절을 사용하는 테이블을 뷰로 생성한다
* 업무에따라 테이블을 이용하는 구분이 달라질 수 있다.
* 사용 데이터를 다양한 관점에서 제시

클러스터 설계
- 클러스터(Cluster)의 개요
* 데이터 저장 시 데이터 액세스 효율을 향상시키기 위해 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법이다.
- 클러스터(Cluster)의 특징
* 데이터 조회 속도는 향상시키지만 데이터 입력, 수정, 삭제에 대한 성능은 저하시킨다.
* 파티셔닝된 테이블에는 클러스터링을 할 수 없다.
* 데이터 분포도가 넓은 테이블을 클러스터링할시 저장공간을 절약할 수 있다.
- 클러스터 대상 테이블
* 분포도가 넓은 테이블
* 대량의 범위를 자주 조회하는 테이블
* 입력/수정/삭제가 자주 발생하지 않는 테이블
* 자주 조인되어 사용되는 테이블

파티션 설계
- 파티션(Patition)의 개요 : 분산 저장, 별도의 공간에 저장
* 대용량의 테이블이나 인덱스를 / 작은 논리적 단위인 파티션으로 나누는 것이다.
- 파티션의 장점
* 파티션별로 데이터가 분산되어 저장되므로 디스크의 성능이 향상된다.
* 파티션별로 백업 및 복구를 수행하므로 속도가 빠르다	/ 데이터에 대한 가용성이 증가한다.
* 시스템 장애 시 데이터 손상 정도를 최소화 할 수 있다.
- 파티션의 단점
* 세심한 관리가 요구된다, 테이블 간 조인에 대한 비용이 증가한다.
* ex)용량이 작은 테이블에 파티션 수행하더라도 성능이 저하될 수 있다.
- 파티션(Patition)의 종류
* 범위분할(Range Partitioning)[지정된 열의 값을 기준으로 분할], 해시분할(Hash Partitioning)[해시함수에 적용한 결과값에 따른 분할]
* 조합분할(Composite Partitioning)[범위분할로 분할한 뒤 해시함수를 적용하여 다시 분할하는 방식]
- 인덱스 파티션
* 파티션된 테이블의 종속 여부에 따라[로컬, 글로벌]
# Local Partitioned Index[테이블 파티션 과 인덱스 파티션이 1:1로 대응되도록 제작]. Global Patitioned Index[테이블 파티션 과 인덱스 파티션이 독립적으로 구성되도록 제작]
# Local Partitioned Index 가 Global Patitioned Index 에 비해 데이터 관리가 쉽다.
* 인덱스 파티션키 컬럼의 위치에 따라
# Prefixed Partitioned Index[인덱스 파티션키와 인덱스 첫번째 컬럼이 같다]. Non-Prefixed Partitioned Index[인덱스 파티션키와 인덱스 첫번째 컬럼이 다르다].

데이터베이스 용량 설계
- 데이터베이스 용량 설계
* 데이터가 저장될 공간을 정의하는 것이다.(예측 -> 반영)
- 데이터베이스 용량 설계의 목적
* 용량을 정확히 산정하여 디스크의 저장 공간을 효과적으로 사용하고 확장성 및 가용성을 높인다.
* 디스크의 입출력에 대한 부하를 분산시킬 수 있다. => 데이터에 대한 접근성 향상
* 채널의 병목현상을 줄일수 있다.
* DB에 생성되는 익스턴트(추가 할당 공간)을 최소화 하는것으로 성능이 향상시킬수 있다.
- 데이터베이스 용량 분석 절차
* 기초 자료를 수집하여 용량을 분석한다 - 오브젝트별 용량을 산정한다.
* (예상 건수, Row 길이, 보존기간, 증가율) - (테이블, 인덱스)
=> 테이블, 인덱스의 테이블 스페이스의 용량을 산정한다.
테이블 스페이스 내 테이블 용량 모두 더하기 40% 추가 = DB 모든 데이터 용량 + 시스템 용량 = 총 디스크 용량

분산 데이터베이스 설계
- 분산 데이터베이스 정의
* 논리적으로는 하나의 시스템에 속하지만 / 물리적으로는 네트워크를 통해 연결된 여러개의 컴퓨터 사이트에 분산되어 있는 데이터베이스이다.
- 분산 데이터베이스의 구성 요소
* 분산 처리기(처리능력, 시스템), 분산 데이터베이스(데이터), 통신 네트워크(통신망으로 연결)
- 분산 데이터베이스 설계 시 고려 사항
* 작업부하의 노드별 분산 정책, 지역의 자치성 보장 정책, 데이터의 일관성 정책, 고장 회복기능, 통신 접속 가능
- 분산 데이터베이스의 목표
* 위치 투명성(Location Transparency), 중복 투명성(Replication Transparency) = 복제 투명성
* 병행 투명성(Concurrency Transparency), 장애 투명성(Failure Transparency)[장애가 있어도 트랜잭션은 정확하게 처리가 되어야 한다]
- 분산 데이터베이스 장/단점
* 장점 : 지역 자치성이 높다[자료에 대한 공유성 향상, 분산제어 가능], 시스템 성능이 향상된다, 효율성과 융통성이 높다, 장애로 인한 문제가 발생하더라도 다른 데이터베이스에는 영향이 없다
* 단점 : 소프트웨어 개발비용이 증가한다[설계가 어렵다, 처리비용이 증가한다, 잠재적 오류가 존재한다], 잠재적 오류가 증가한다.
- 분산 데이터베이스 설계
* 애플리케이션이나 사용자가 분산되어 저장된 데이터에 접근하게 하는것이 목적
- 테이블 위치 분산
* 데이터베이스의 테이블을 각기 다른 서버에 분산시켜 배치하는 방법
* 잘못된 설계로 인해 복잡석이 증가하고, 응답속도가 느려지며, 비용이 증가할 수 있다.
- 분할(Fragment)
* 테이블의 데이터를 분할하여 분산시키는 것
* 분할 규칙 : 완정성(Completeness)[전체 데이터 대상], 재구성(Reconstruction), 상호 중첩 배제(Dis-jointness)
* 관계연산 활용 : 본래의 데이터 재구성 가능, 분할된 데이터 : 서로 다른 분할 항목에 속하지 않는다.
- 할당(Alloction)
* 동일한 분할을 여러개의 서버에 생성하는 분산 방법

데이터베이스 이중화/서버 클러스터링
- 데이터베이스 이중화(Database Replication) : 일종의 백업본?
* 동일한 데이터베이스를 복제하여 관리하는 것이다.
- 데이터베이스 이중화의 분류(변경 내용의 전달 방식에 따라)
* Eager 기법, Lazy 기법
- 데이터베이스 이중화 구성 방법
* 활동-대기(Active-Standby) 방법, 활동-활동(Active-Active) 방법
* [A라는 DB가 활동상태이고 B라는 DB는 대기상태일때, A가 문제가 발생할경우, B가 모든 서비스를 대신 수행], [A라는 DB와 B라는 DB가 모두 활동상태일때(서로 다른 서비스를 제공), 한쪽 DB에서 문제가 발생시 다른 DB가 서비스를 제공]
- 클러스터링(Clustering)
* 두 대 이상의 서버를 하나의 서버처럼 운영하는 기술
* 고가용성 클러스터링 : 하나의 서버에 장애가 발생시 다른서버에서 서비스를 제공
* 병렬처리 클러스터링 : 하나의 작업을 처리할때, 여러개의 서버가 분산해서 처리

데이터베이스 보안/암호화
- 데이터베이스 보안의 개요
* 데이터베이스의 권한이 없는 사용자가 액세스하는것을 금지하기 위해 사용되는 기술
- 암호화(Encryption)
* 개인키 암호 방식(Private Key Encryption)[비밀키 암호 방식] = 동일한 키로 데이터를 암호화하고 복호화 한다.
# 대칭키 암호화 방식
* 공개키 암호 방식(Public Key Encryption) : 서로 다른 키로 데이터를 암호화하고 복호화 한다.
# 비대칭키 암호화 방식

데이터베이스 보안 - 접근통제
- 접근통제
* 객체와 이를 사용하려는 주체 사이의 정보 흐름을 제한하는 것, 불법접근 및 파괴 예방
* 비인가된 사용자, 접근요구자에 대한 식별, 접근요구 정당성, 보안정책 승인/거부
* 임의 접근통제(DAC) : 사용자의 신원에 따라 접근권한 부여 => 주체
* 강제 접근통제(MAC) : 객체의 등급, 주체의 등급에 따른 접근권한 부여 => 제 3자가 권한 지정
* 접근통제의 3요소 : 접근통제 정책, 접근통제 매커니즘, 접근통제 보안모델
- 접근통제 정책
* 어떤 주체가 언제, 어디서, 어떤 객체에게 어떤 행위에 대한 허용 여부를 정의하는 것
* 신분기반 정책, 규칙기반 정책, 역할기반 정책 
# 신분 : IBP(최소 권한 정책, 단일 주체, 1개체허가), GBP(복수 권한 정책, 복수 주체, 1개체허가)
# 규칙 : 주체가 갖는 권한, 객체 접근, MLP(사용자, 객체별로 분류), CBP(집단별로 분류)

데이터베이스 보안 - 접근통제
- 요소 : 매커니즘, 보안모델, 조건, 감사 추적
- 접근통제 매커니즘
* 정의된 접근통제 정책을 구현하는 기술적인 방법
* 접근통제 목록[객체, 주체, 행위], 능력 리스트[특정한 주체에게 허가된 자원], 보안 등급[주체 및 객체에 주어짐], 패스워드, 암호화
- 접근통제 보안 모델
* 보안 정책을 구현하기 위한 정형화된 모델이다. 기밀성 모델[군사적인 목적으로 개발, 기밀성 보장], 무결성 모델[불법적 정보변경 방지, 일관성 유지], 접근통제 모델[접근 통제 행렬]
- 접근통제 조건
* 값 종속 통제, 다중 사용자[동시 접근] 통제, 컨텍스트 기반[시간, 네트워크주소, 접근경로, 인증 수준] 통제
- 감사 추적
* 사용자나 애플리케이션이 데이터베이스에 접근하여 수행한 모든 활동을 기록하는 기능

데이터베이스 백업
- 데이터베이스 백업
* 장애에 대비하여 데이터베이스에 저장된 데이터를 보호하고 복구하기 위한 작업이다.
- 데이터베이스 장애 유형
* 사용자 실수, 미디어 장애, 구문[프로그램, 사용공간] 장애, 사용자 프로세스 장애[비정상적 종료, 네트워크 이상], 인스턴스 장애[HW 장애, 정전, 시스템 파일 파손]
- 데이터베이스 복구 알고리즘
* 종류 : NO-UNDO/REDO, UNDO/NO-REDO, UNDO/REDO, NO-UNDO/NO-REDO
* UNDO : 기록한 내용 취소
* REDO : 다시 실행
- 백업 종류
* 물리백업[OS이용], 논리백업[DBMS 유틸리티]

스토리지
- 스토리지(Storge)의 개요
* 대용량의 데이터를 저장하기 위해 서버와 저장장치를 연결하는 기술
- DAS(Direct Attached Storage)
* 서버와 저장장치를 전용 케이블로 직접 연결하는 방식
* 장점 : 속도가 빠르다, 설치가 간편하다, 비용이 저렴하다
* 단점 : 다른 서버에서 접근하기 힘들다, 공유가 불가능하다, 확장성 및 유연성이 떨어진다
- NAS(Network Attached Storage)
* 서버와 저장장치를 네트워크를 통해 연결하는 방식
* 장점 : 다른서버에서 접근이 가능하다, 확장성 및 유연성 높다
* 단점 : 접속증가로 인해 성능이 저하된다
- SAN(Storage Area Network)
* 서버와 저장장치를 연결하는 전용 네트워크를 별도로 구성하는 방식
* DAS 와 NAS 를 혼합한 방식이다.

논리 데이터 모델의 물리 데이터 모델 변환
- 테이블(Table)
* 데이터를 저장하는 데이터베이스의 가장 기본적인 오브젝트이다
* 로우(Row), 컬럼(Column), 기본키(Primary Key), 외래키(Foreign key)
# 논리 : 엔티티 | 속성 | 주 식별자 | 외부 식별자
# 물리 : 테이블 | 칼럼 | 기본키 | 외래키
- 엔티티(Entity)를 테이블로 변환
* 논리 데이터 모델에서 정의된 엔티티[한글명]를 물리 데이터 모델의 테이블[영문명]로 변환하는 것
- 슈퍼타입/서브타입을 테이블로 변환
* 물리 데이터 모델을 설계할 때는 슈퍼타입/서브타입을 테이블로 변환해야 한다.
* 슈퍼타입 기준 테이블 변환[서브타입을 슈퍼타입에 통합], 서브타입 기준 테이블 변환[슈퍼타입을 서브타입에 통합], 개별타입 기준 테이블 변환
- 속성을 컬럼으로 변환
* 일반 속성 변환, Primary UID(식별자)를 기본키로 변환
* Primary UID(관계의 UID Bar)를 기본키로 변환
* Secondary(Alternate) UID를 유니크키(식별자)로 변환
- 관계를 외래키로 변환
* 1:1관계 : A의 기본키 -> B 추가, B의 외래키 -> A 추가
* 1:N 관계 : A의 기본키 -> B 추가, 별도의 테이블로 표현
* N:M관계 : A, B의 기본키 모두 포함, 별도의 테이블로 표현
- 관리 목적의 테이블/컬럼 추가
- 데이터 타입 선택
* 문자 타입, 숫자 타입, 날짜 타입

물리 데이터 모델 품질 검토
- 물리 데이터 모델 품질 검토
* 물리 데이터 모델 품질 검토의 목적은 데이터베이스의 성능 향상과 오류 예방이다.
* 물리 데이터 모델을 검토하려면 모든 이해관계자가 동의하는 검토 기준이 필요하다.
- 물리 데이터 모델 품질 기준
* 정확성(요구사항 및 규칙), 완전성(구성요소), 준거성(표준, 규칙), 최신성(최신 이슈), 일관성, 활용성(사용자의 모델에 대한 이해)이다.
* 조직 혹은 업무 상황에 따라 가감하거나 변형하여 사용한다.
- 물리 데이터 모델 품질 검토 항목
* 물리 데이터 모델의 특성을 반영한 품질 기준을 작성한 후 이를 기반으로 작성한다.
- 물리 데이터 모델 품질 검토 순서
* 품질 정책 기준 확인 - 품질 기준 작성 - 체크리스트 작성 - 논리, 물리 비교 - 품질 검토 수행 - 보고서 작성