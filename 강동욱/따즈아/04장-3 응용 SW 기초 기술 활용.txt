운영체제의 개념
- 운영체제(OS : Operation System)의 정의
* 시스템의 자원을 효율적으로 관리, 편리하고 효과적으로 사용할 수 있도록 환경을 제공
* 하드웨어와 소프트웨어 사이에 존재하며, 다른 응용 프로그램들이 유용한 작업을 할 수 있도록 환경을 제공
- 운영체제의 목적
* 처리 능력 향상[주어진 시간내 시스템 처리양], 반환 시간 단축[명령 후 완료까지 시간], 사용 가능도 향상[즉시 사용], 신뢰도 향상[정확성]
- 운영체제의 기능 : 자원의 스케줄링, 사용자-시스템 간 인터페이스 제공
* 프로세서, 기억장치, 입/출력 장치, 파일 및 정보 등의 자원을 관리
- 운영체제의 주요 자원 관리
* 프로세스 관리, 기억장치 관리, 주변장치 관리, 파일 관리
- 운영체제의 종류
* Windows, UNIX, LINUX, MacOs, MS-DOS

Windows
- Windows의 개요
* 그래픽 사용자 인터페이스(GUI : Graphic User Interface)
* 선점형 멀티캐스킹(Preemptive Multi-Tesking) : 강제종료 가능, 동시에 여러개의 프로그램 실행 가능
* PnP(Plug and Play, 자동 감지 기능)
* OLE(Object Linking and Embedding)
* 255자의 긴 파일명
* Single-User 시스템
# 멀티 프로그래밍 :  , 멀티 프로세싱 : 여러개의 CPU가 여러개의 프로그램을 처리하는것

UNIX / LINUX / MacOS
- UNIX의 개요 및 특징
* 대화식 운영체제, 이식성이 높다
* 다중 사용자(Multi-User), 다중 작업(Multi-Tasking)을 지원한다.
* 트리 구조의 파일 시스템을 갖는다.
* 시분할 시스템 지원하기 위해 설계된 운영체제
- UNIX 시스템의 구성
* 커널(Kernel) : UNIX의 가장 핵심적인 부분 - 관리[프로세스, 기억장치, 파일, 입출력, 통신, 정손변환] 및 제어역할
# 유닉스의 핵심 부분, 주기억장치에 적재 후 컴퓨터 종료까지 계속해서 상주
* 쉘(Shell) : 사용자의 명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 명령어 해석기
- LINUX : UNIX의 축소판, 소스무료공개
- MacOS : 애플사 UNIX 기반 개발

기억장치의 관리의 개요
- 기억장치 계층 구조의 특징
* 기억장치는 레지스터[CPU 내부 존재, 속도가 가장 빠름], 캐시 기억장치, 주기억장치, 보조기억장치 계층 구조로 분류
- 기억장치의 관리 전략의 개요
* 한정된 주기억장치의 공간을 효율적으로 사용
* 반입전략, 배치전략, 교체 전략
- 반입(Fetch)전략
* 언제 주기억장치로 적재할 것인지 결정(요구 반입, 예상 반입)
- 배치(Placement)전략
* 주기억장치의 어디에 위치시킬 것인지를 결정
* 최초 적합(First Fit)[처음 만나는 저장공간에 배치], 최적 적합(Best Fit)[데이터의 크기와 저장공간의 크기가 가장 비슷한 곳에 배치], 최악 적합(Worst Fit)[저장공간의 크기에서 데이터의 크기를 뺏을때 가장 많이 남아있는 공간이 있는곳에 배치]
- 교체(Replacement)전략
* 어느 영역을 교체하여 사용할 것인지를 결정하는 전략
* FIFO, LRU, LFU 등
#LRU : 가장 오랫동안 참조하지 않은 페이지 교체
#LFU : 참조된 횟수가 가장 적은 페이지 교체

주기억장치 할당 기법
- 주기억장치 할당의 개념
* 연속 할당 기법 : 연속으로 할당하는 기법, 단일 분할 할당 기법, 다중 분할 할당 기법
* 분산 할당 기법 : 분산하여 할당하는 기법, 페이징 기법, 세그먼테이션 기법
- 단일 분할 할당 기법 : 1인의 사용자가 주기억장치를 사용하는 것
* 오버레이 기법 : 주기억장치보다 큰 사용자 프로그램을 실행하기 위한 기법
* 스와핑 기법 : 필요에 따라 다른프로그램과 교체하는 기법
- 다중 분할 할당 기법
* 고정 분할 할당 기법(정적 할당 기법) : 고정된 크기로 분할
# 프로그램 전체가 주기억장치에 위치해야 한다.
# 내부 단편화 : 프로그램이 저장공간에 들어가고 남아있는 공간
# 외부 단편화 : 프로그램이 저장공간에 들어가지 못하고 남아있는 공간
* 가변 분할 할당 기법(동적 할당 기법) : 필요한 만큼의 크기로 영역을 분할하는 기법

가상기억장치 구현 기법 / 페이지 교체 알고리즘
- 가상기억장치의 개요
* 보조기억장치(하드디스크)의 일부를 주기억장치처럼 사용하는 것
# 주기억장치의 용량보다 큰 프로그램을 실행
# 주기억장치의 이용률과 다중 프로그래밍의 효율을 높일 수 있다.
# 주소변환 과정 필요
- 페이징(Paging) 기법
* 프로그램(페이지)을 동일하게 나눠진 주기억장치의 영역(페이지 프레임)에 적재
* 외부단편화 발생안함, 내부단편화 발생
- 세그먼테이션(Segmentation) 기법
* 프로그램을 다양한 크기의 논리적인 단위로 나눈 후 주기억장치에 적재시켜 실행
* 외부단편화 발생, 내부단편화 발생안함
- 페이지 교체 알고리즘
* 페이지 프레임을 선택하여 교체할 것인지를 결정하는 기법
* OTP(최적 교체) : 앞으로 오랫동안 사용하지 않을 페이지 교체
* FIFO(First In First Out) : 가장 먼저 들어온 페이지 교체
* LRU(Least Recently Used) : 가장 오랫동안 사용하지 않은 페이지 교체
* LFU(Least Frequently Used) : 빈도가 가장 적은 페이지 교체
* NUR(Not Used Recently) : 참조비트, 변형비트 나열 후 순서 결정
* SCR(Second Chance Replacement, 2차 기회 교체)
# FIFO 단점 보안

가상기억장치 기타 관리 사항
- 페이지 크기
* 작을 경우 : 페이지 맵 테이블의 크기가 커지고, 매핑 속도가 늦어진다.
# 장점 : 페이지 단편화 감소, 기억장치 효율 좋음
# 단점 : 디스크에 접근횟수가 증가, 입/출력시간 증가
* 클 경우 : 페이지 맵 테이블의 크기가 작아지고, 매핑 속도가 빨라진다.
# 장점 : 입/출력 시간 감소
# 단점 : 페이지 단편화 증가, 주기억장치까지 이동시간 증가
- Locality(국부성, 지역성, 구역성, 국소성)
* 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조
# 지역성 : 시간지역성[가까운 시간내 재참조], 공간지역성[하나의 데이터를 참조할때 근처의 데이터들도 참조, 배열, 순회]
- 워킹 셋(Working Set) : [지역성을 이용하여 주기억장치에 상주, 시간에 따라 변함]
* 프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합
- 프리페이징(Prepaging) : 필요할 것 같은 모든 페이지를 한꺼번에 페이지 프레임에 적재하는 기법
- 스래싱(Thrashing) : 프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상
* 다중프로그래밍에 대한 정도가 높아지게 되면 스래싱 현상이 발생하기 쉬워진다. -- 적정 수준 유지, 부족한 자원 증설, 해당 프로세스 중단

프로세스의 개요
- 프로세스(Process)의 정의 : 현재 실행중인 프로그램
* PCB를 가진 프로그램, OS관리 실행단위, (비동기적[비규칙적, 비연속적] 행위 주체 => 독립적 실행)
- PCB(Process Control Block, 프로세스 제어 블록)
* 운영체제가 프로세스에 대한 중요한 정보를 저장해 놓은 곳
* 프로세스의 현 상태 저장, 포인터(부모, 자식)
* 프로세스 고유 식별자, 스케줄링, 프로세스에 대한 우선순위
* PC(프로그램 카운터 : 다음에 실행할 명령어를 저장하는것)정보
- 프로세스 상태 전이
* 프로세스가 시스템 내에 존재하는 동안 프로세스의 상태가 변하는 것
* 프로세스 상태 : 제출(Submit), 접수(Hold), 준비(Ready), 실행(Run), 대기(Wait), 종료(Terminated, Exit)
# 순서 : 제출 --> 접수 --> 준비 - DisPatch -> 실행 --> 종료
			^ <-TimeOut-
		        Wake Up-  대기   <I/O-
- 스레드(Thread)
* 프로세스 내에서의 작업 단위로서 시스템의 여러 자원을 할당받아 실행하는 프로그램의 단위
* 단일 스레드 : 스레드에 존재[힙, 정적, 코드, 레지스터, 스택]
* 다중 스레드 : 스레드마다 공유 영역(힙, 정적, 코드), 고유영역(레지스터, 스택)
# 사용자수준 : 사용자가 만든 라이브러리 사용 및 운영
# 커널 수준 : OS 커널 사용 및 운영 
* 병행성 증진, 처리율 증가
