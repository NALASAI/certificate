디자인 패턴의 개요
- 디자인 패턴은 재사용할 수 있는 기본형 코드들이 포함되어 있음
- 생성 패턴 / 구조 패턴 / 행위 패턴

생성 패턴 (Creational Pattern)
- 객체의 생성과 참조 과정을 캡슐화하여 프로그램에 유연성을 더해줌
1) 추상 팩토리 (Abstract Factory)
- 구체적인 클래스에 의존하지 않고 인터페이스를 통해 서로 의존하는 객체들의 그룹으로 생성
- 연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능
2) 빌더 (Builder)
- 작게 분리된 인스턴스를 건축하듯이 조합하여 객체 생성
3) 팩토리 메소드 (Factory Method)
- 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화
- 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당
4) 프로토타입 (Prototype)
- 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴
5) 싱글톤 (Singleton)
- 하나의 객체를 생성하면 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조하는 것은 불가능
- 클래스 내 인스턴스가 하나뿐임을 보장하여 불필요한 메모리 낭비 최소화

구조 패턴 (Structural Pattern)
- 클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴
- 구조가 복잡한 시스템을 개발하기 쉽게 도와줌
1) 어댑터 (Adapter)
- 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴
2) 브리지 (Bridge)
- 기능과 구현을 두 개의 별도 클래스로 구현
3) 컴포지트 (Composite)
- 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용
4) 데코레이터 (Decorator)
- 객체 간 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴
5) 퍼싸드 (Facade)
- 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성
- 서브 클래스들의 기능을 간편하게 사용할 수 있도록 도와줌
6) 플라이웨이트 (Flyweight)
- 인스턴스가 필요할 때마다 매번 생성하는 것이 아닌 가능한 한 공유해서 사용함으로써 메모리 절약
7) 프록시 (Proxy)
- 접근이 어려운 객체와 연결하려는 객체 사이 인터페이스 역할을 수행하는 패턴
- 네트워크 연결, 메모리 대용량 객체로의 접근 등에 주로 이용

행위 패턴 (Behavioral Pattern)
- 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴
- 하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 결합도를 최소화
1) 책임 연쇄 (Chain of Responsibility)
- 한 객체가 요청을 처리하지 못하면 다음 객체로 넘어가는 형태
2) 커맨드 (Command)
- 요청을 캡슐화하여 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴
3) 인터프리터 (Interpreter)
- 언어에 문법 표현을 정의하는 패턴
4) 반복자 (Iterator)
- 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴
5) 중재자 (Mediator)
- 객체 간 상호작용을 캡슐화하여 객체로 정의하는 패턴
6) 메멘토 (Memento)
- 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공
7) 옵저버 (Observer)
- 한 객체의 상태가 변하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달
8) 상태 (State)
- 객체 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용
9) 전략 (Strategy)
- 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의
- 클라이언트 영향 업이 알고리즘 변경 가능
10) 템플릿 메소드 (Template Method)
- 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 구조
11) 방문자 (Visitor)
- 각 클래스에서 처리 기능을 분리하여 별도 클래스로 구성하는 패턴